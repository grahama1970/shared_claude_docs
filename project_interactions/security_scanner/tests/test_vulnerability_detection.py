"""
Test vulnerability detection capabilities

External Dependencies:
- pytest: https://docs.pytest.org/
"""

import sys
from pathlib import Path

# Add src to path for imports
src_path = Path(__file__).parent.parent / "src"
if src_path.exists() and str(src_path) not in sys.path:
    sys.path.insert(0, str(src_path))



import pytest
from pathlib import Path
import tempfile
import shutil
from typing import List

from security_scanner_interaction import (
    SecurityScannerInteraction,
    VulnerabilityType,
    Severity,
    Vulnerability
)


class TestVulnerabilityDetection:
    """Test vulnerability detection across different languages"""
    
    @pytest.fixture
    def scanner(self):
        """Create scanner instance"""
        return SecurityScannerInteraction()
    
    @pytest.fixture
    def temp_project(self):
        """Create temporary project directory"""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir)
        shutil.rmtree(temp_dir)
    
    def test_sql_injection_detection(self, scanner, temp_project):
        """Test SQL injection detection in Python"""
        # Create vulnerable Python file
        vuln_file = temp_project / "sql_vulnerable.py"
        vuln_file.write_text('''
import mysql.connector

def get_user_unsafe(user_id):
    # Vulnerable to SQL injection
    query = f"SELECT * FROM users WHERE id = {user_id}"
    cursor.execute(query)
    return cursor.fetchall()

def get_user_safe(user_id):
    # Safe parameterized query
    query = "SELECT * FROM users WHERE id = %s"
    cursor.execute(query, (user_id,))
    return cursor.fetchall()

def delete_user(username):
    # Another SQL injection
    query = "DELETE FROM users WHERE username = '" + username + "'"
    cursor.execute(query)
''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify SQL injection vulnerabilities detected
        sql_vulns = [v for v in result.vulnerabilities 
                     if v.type == VulnerabilityType.INJECTION]
        
        assert len(sql_vulns) >= 2, f"Expected at least 2 SQL injections, found {len(sql_vulns)}"
        assert any('SELECT' in v.code_snippet for v in sql_vulns)
        assert any('DELETE' in v.code_snippet for v in sql_vulns)
        
        # Check severity and CWE
        for vuln in sql_vulns:
            assert vuln.severity in [Severity.HIGH, Severity.CRITICAL]
            assert vuln.cwe_id == "CWE-89"
            assert vuln.remediation is not None
    
    def test_xss_detection(self, scanner, temp_project):
        """Test XSS detection in JavaScript"""
        # Create vulnerable JavaScript file
        vuln_file = temp_project / "xss_vulnerable.js"
        vuln_file.write_text('''
function displayUserComment(comment) {
    // XSS vulnerability - directly setting innerHTML
    document.getElementById('comments').innerHTML = comment;
}

function showMessage(msg) {
    // Another XSS
    document.write('<div>' + msg + '</div>');
}

function executeUserCode(code) {
    // Code injection via eval
    eval(code);
}

function safeDisplay(text) {
    // Safe approach using textContent
    document.getElementById('output').textContent = text;
}
''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify XSS vulnerabilities detected
        xss_vulns = [v for v in result.vulnerabilities 
                     if v.type == VulnerabilityType.XSS]
        
        assert len(xss_vulns) >= 2, f"Expected at least 2 XSS vulnerabilities, found {len(xss_vulns)}"
        assert any('innerHTML' in v.code_snippet for v in xss_vulns)
        assert any('document.write' in v.code_snippet for v in xss_vulns)
        
        # Check eval detection
        cmd_vulns = [v for v in result.vulnerabilities 
                     if v.type == VulnerabilityType.COMMAND_INJECTION]
        assert any('eval' in v.code_snippet for v in cmd_vulns)
    
    def test_command_injection_detection(self, scanner, temp_project):
        """Test command injection detection"""
        # Create vulnerable Python file
        vuln_file = temp_project / "cmd_vulnerable.py"
        vuln_file.write_text('''
import os
import subprocess

def run_user_command(user_input):
    # Command injection vulnerability
    os.system("ping " + user_input)

def execute_with_shell(cmd):
    # Another command injection
    subprocess.run(f"echo {cmd}", shell=True)

def safe_subprocess(arg):
    # Safe approach
    subprocess.run(["echo", arg], shell=False)
    
def dangerous_eval(user_code):
    # Code injection via eval
    result = eval(user_code)
    return result
''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify command injection vulnerabilities
        cmd_vulns = [v for v in result.vulnerabilities 
                     if v.type == VulnerabilityType.COMMAND_INJECTION]
        
        assert len(cmd_vulns) >= 3, f"Expected at least 3 command injections, found {len(cmd_vulns)}"
        assert any('os.system' in v.code_snippet for v in cmd_vulns)
        assert any('subprocess' in v.code_snippet for v in cmd_vulns)
        assert any('eval' in v.code_snippet for v in cmd_vulns)
        
        # All should be critical
        for vuln in cmd_vulns:
            assert vuln.severity == Severity.CRITICAL
    
    def test_hardcoded_secrets_detection(self, scanner, temp_project):
        """Test detection of hardcoded secrets"""
        # Create file with various secrets
        vuln_file = temp_project / "secrets.py"
        vuln_file.write_text('''
# Configuration file with secrets

API_KEY = "sk-1234567890abcdefghijklmnopqrstuvw"
AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
DATABASE_URL = "postgresql://user:password123@localhost/mydb"
SECRET_TOKEN = "my-super-secret-token-that-should-not-be-here"

class Config:
    password = "VerySecurePassword123!"
    oauth_token = "ya29.a0AfH6SMBx-0bDiZFakeTokenExample"
    
# This should not trigger (too short)
short_key = "abc123"

# Example/test should be ignored
EXAMPLE_API_KEY = "example-key-12345"
''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify secret detection
        secret_vulns = [v for v in result.vulnerabilities 
                       if v.type == VulnerabilityType.HARDCODED_SECRET]
        
        assert len(secret_vulns) >= 5, f"Expected at least 5 hardcoded secrets, found {len(secret_vulns)}"
        
        # Check different secret types detected
        secret_types = {v.description for v in secret_vulns}
        assert any('api key' in s.lower() for s in secret_types)
        assert any('aws' in s.lower() for s in secret_types)
        assert any('password' in s.lower() for s in secret_types)
        assert any('token' in s.lower() for s in secret_types)
        
        # All secrets should be critical
        for vuln in secret_vulns:
            assert vuln.severity == Severity.CRITICAL
            assert vuln.cwe_id == "CWE-798"
    
    def test_path_traversal_detection(self, scanner, temp_project):
        """Test path traversal vulnerability detection"""
        # Create vulnerable file
        vuln_file = temp_project / "path_traversal.py"
        vuln_file.write_text('''
import os
from pathlib import Path

def read_user_file(filename):
    # Path traversal vulnerability
    with open("uploads/" + filename, 'r') as f:
        return f.read()

def download_file(user_path):
    # Another path traversal
    file_path = Path("downloads") / user_path
    return file_path.read_text()

def check_path_traversal(path):
    # Checking for ../ pattern
    if "../" in path or "..\\\\" in path:
        raise ValueError("Path traversal detected")
''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify path traversal detection
        path_vulns = [v for v in result.vulnerabilities 
                     if v.type == VulnerabilityType.PATH_TRAVERSAL]
        
        assert len(path_vulns) >= 2, f"Expected at least 2 path traversal vulnerabilities"
        
        for vuln in path_vulns:
            assert vuln.severity == Severity.HIGH
            assert vuln.cwe_id == "CWE-22"
    
    def test_weak_crypto_detection(self, scanner, temp_project):
        """Test weak cryptography detection"""
        # Create file with weak crypto
        vuln_file = temp_project / "weak_crypto.py"
        vuln_file.write_text('''
import hashlib
from Crypto.Cipher import DES, AES

def hash_password_weak(password):
    # Weak: MD5
    return hashlib.md5(password.encode()).hexdigest()

def hash_data_weak(data):
    # Weak: SHA1
    return hashlib.sha1(data.encode()).hexdigest()

def encrypt_weak(data, key):
    # Weak: DES
    cipher = DES.new(key, DES.MODE_ECB)
    return cipher.encrypt(data)

def hash_password_strong(password):
    # Strong: SHA256
    return hashlib.sha256(password.encode()).hexdigest()
''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify weak crypto detection
        crypto_vulns = [v for v in result.vulnerabilities 
                       if v.type == VulnerabilityType.WEAK_CRYPTO]
        
        assert len(crypto_vulns) >= 3, f"Expected at least 3 weak crypto vulnerabilities"
        
        # Check specific weak algorithms detected
        algorithms = {v.code_snippet for v in crypto_vulns}
        assert any('md5' in a.lower() for a in algorithms)
        assert any('sha1' in a.lower() for a in algorithms)
        assert any('des' in a.upper() for a in algorithms)
        
        for vuln in crypto_vulns:
            assert vuln.severity == Severity.MEDIUM
            assert vuln.cwe_id == "CWE-327"
    
    def test_xxe_detection_java(self, scanner, temp_project):
        """Test XXE detection in Java files"""
        # Create vulnerable Java file
        vuln_file = temp_project / "XXEVulnerable.java"
        vuln_file.write_text('''
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import org.w3c.dom.Document;

public class XXEVulnerable {
    public Document parseXML(String xmlFile) {
        // Vulnerable to XXE - no feature configuration
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document doc = db.parse(xmlFile);
        return doc;
    }
    
    public Document parseXMLSafe(String xmlFile) {
        // Safe from XXE
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document doc = db.parse(xmlFile);
        return doc;
    }
}
''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify XXE detection
        xxe_vulns = [v for v in result.vulnerabilities 
                     if v.type == VulnerabilityType.XXE]
        
        assert len(xxe_vulns) >= 1, "Expected at least 1 XXE vulnerability"
        assert xxe_vulns[0].severity == Severity.HIGH
        assert xxe_vulns[0].cwe_id == "CWE-611"
    
    def test_php_injection_detection(self, scanner, temp_project):
        """Test PHP-specific injection detection"""
        # Create vulnerable PHP file
        vuln_file = temp_project / "vulnerable.php"
        vuln_file.write_text('''<?php
// SQL injection in PHP
$user_id = $_GET['id'];
$query = "SELECT * FROM users WHERE id = " . $user_id;
mysql_query($query);

// Command injection
$filename = $_POST['file'];
system("cat " . $filename);

// Another SQL injection
$username = $_POST['username'];
$sql = "SELECT * FROM users WHERE username = '$username'";
mysql_query($sql);
?>''')
        
        # Scan the file
        result = scanner.scan_project(str(temp_project))
        
        # Verify PHP vulnerabilities
        php_vulns = [v for v in result.vulnerabilities 
                     if v.file_path.endswith('.php')]
        
        assert len(php_vulns) >= 3, f"Expected at least 3 PHP vulnerabilities"
        
        # Check for SQL and command injection
        assert any(v.type == VulnerabilityType.INJECTION for v in php_vulns)
        assert any('$_GET' in v.code_snippet or '$_POST' in v.code_snippet 
                  for v in php_vulns)
    
    def test_multiple_language_scan(self, scanner, temp_project):
        """Test scanning project with multiple languages"""
        # Create files in different languages
        
        # Python file
        (temp_project / "app.py").write_text('''
password = "hardcoded_password"
eval(user_input)
''')
        
        # JavaScript file
        (temp_project / "app.js").write_text('''
document.innerHTML = userContent;
const apiKey = "sk-secret-key-12345";
''')
        
        # Java file
        (temp_project / "App.java").write_text('''
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
''')
        
        # Scan entire project
        result = scanner.scan_project(str(temp_project))
        
        # Should find vulnerabilities in all languages
        assert result.files_scanned >= 3
        assert result.total_vulnerabilities >= 4
        
        # Check variety of vulnerability types
        vuln_types = {v.type for v in result.vulnerabilities}
        assert len(vuln_types) >= 3, "Should detect multiple vulnerability types"


if __name__ == "__main__":
    # Run tests directly
    tester = TestVulnerabilityDetection()
    scanner = SecurityScannerInteraction()
    
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_project = Path(temp_dir)
        
        # Run individual tests
        print("Testing SQL injection detection...")
        tester.test_sql_injection_detection(scanner, temp_project)
        print("✅ SQL injection detection passed")
        
        print("\nTesting XSS detection...")
        tester.test_xss_detection(scanner, temp_project)
        print("✅ XSS detection passed")
        
        print("\nTesting command injection detection...")
        tester.test_command_injection_detection(scanner, temp_project)
        print("✅ Command injection detection passed")
        
        print("\nTesting hardcoded secrets detection...")
        tester.test_hardcoded_secrets_detection(scanner, temp_project)
        print("✅ Hardcoded secrets detection passed")
        
        print("\nTesting weak cryptography detection...")
        tester.test_weak_crypto_detection(scanner, temp_project)
        print("✅ Weak cryptography detection passed")
        
        print("\n✅ All vulnerability detection tests passed!")